version: '3'
x-airflow-common:
    &airflow-common
    image: apache/airflow:2.1.2
    environment:
        &airflow-common-env
        LOAD_EX: n
        POSTGRES_USER: ${POSTGRES_USER?Variable not set}
        POSTGRES_PASSWORD: ${POSTGRES_PASSWORD?Variable not set}
        POSTGRES_DB: ${POSTGRES_DB?Variable not set}
        REDIS_HOST: ${REDIS_HOST?Variable not set}
        REDIS_PASSWORD: ${REDIS_PASSWORD?Variable not set}
        AIRFLOW__SCHEDULER__STATSD_ON: 'true'
        AIRFLOW__SCHEDULER__STATSD_HOST: statsd-exporter
        AIRFLOW__SCHEDULER__STATSD_PORT: 8125
        AIRFLOW__SCHEDULER__STATSD_PREFIX: af
        AIRFLOW__CORE__SQL_ALCHEMY_CONN: postgresql://${POSTGRES_PASSWORD?Variable not set}:${POSTGRES_USER?Variable not set}@postgres/${POSTGRES_DB?Variable not set}
        AIRFLOW__CELERY__BROKER_URL: redis://:redis@redis:6379/1
        AIRFLOW__CELERY__RESULT_BACKEND: db+postgresql://${POSTGRES_PASSWORD?Variable not set}:${POSTGRES_USER?Variable not set}@postgres/${POSTGRES_DB?Variable not set}
        AIRFLOW__CORE__FERNET_KEY: ${AIRFLOW__CORE__FERNET_KEY?Variable not set}
        AIRFLOW__CORE__EXECUTOR: CeleryExecutor
        AIRFLOW_HOME: /opt/airflow
        AIRFLOW_CONFIG: /opt/airflow/airflow.cfg
        AIRFLOW__CORE__LOAD_EXAMPLES: 'true'
        AIRFLOW__CORE__LOAD_DEFAULT_CONNECTIONS: 'true'
        AIRFLOW__WEBSERVER__WORKERS: 2
        AIRFLOW__WEBSERVER__WORKER_REFRESH_INTERVAL: 1800
    volumes:
        - ./airflow/dags:/opt/airflow/dags/
        - ./airflow/airflow.cfg:/opt/airflow/airflow.cfg    
        - ./airflow/logs:/opt/airflow/logs
        - ./airflow/plugins:/opt/airflow/plugins
    
services:
    postgres:
        <<: *airflow-common
        image: postgres:13
        volumes:
        - postgres-db-volume:/var/lib/postgresql/data
        healthcheck:
            test: ["CMD", "pg_isready", "-U", "airflow"]
            interval: 5s
            retries: 5
        restart: always

    redis:
        container_name: airflow-redis
        image: 'redis:5.0.5'
        depends_on:
            - statsd-exporter
        command: redis-server --requirepass redis
        ports:
            - 6380:6379
        healthcheck:
            test: ["CMD", "redis-cli", "ping"]
            interval: 5s
            timeout: 30s
            retries: 50
        restart: always

    webserver:
        << : *airflow-common
        container_name: airflow-webserver
        restart: always
        depends_on:
            - postgres
            - redis
            - statsd-exporter
            - airflow-init
        # ports:
        #     - "8080:8080"
        command: airflow webserver
        labels:
            # Enable Traefik for this specific "backend" service
            - traefik.enable=true
            # Define the port inside of the Docker service to use
            - traefik.http.services.airflow.loadbalancer.server.port=8080
            # Make Traefik use this domain in HTTP
            - traefik.http.routers.airflow-http.entrypoints=http
            # Can't think of a good enough name so stole one ðŸ˜‚ðŸ˜‚
            - traefik.http.routers.airflow-http.rule=Host(`compose.mon.${DOMAIN?Variable not set}`)
            # Use the traefik-public network (declared below)
            - traefik.docker.network=traefik-public

            # Make Traefik use this domain in HTTPS
            - traefik.http.routers.airflow-https.entrypoints=https
            - traefik.http.routers.airflow-https.rule=Host(`compose.mon.${DOMAIN?Variable not set}`)
            - traefik.http.routers.airflow-https.tls=true
            # Use the "le" (Let's Encrypt) resolver
            - traefik.http.routers.airflow-https.tls.certresolver=le
            # Middleware to redirect HTTP to HTTPS
            - traefik.http.routers.airflow-http.middlewares=https-redirect
            - traefik.http.routers.airflow-https.middlewares=admin-auth
        networks:
        # Use the public network created to be shared between Traefik and
        # any other service that needs to be publicly available with HTTPS
        - traefik-public
        - default

        healthcheck:
            test: ["CMD-SHELL", "[ -f /opt/airflow/airflow-webserver.pid ]"]
            interval: 30s
            timeout: 30s
            retries: 3

    flower:
        << : *airflow-common
        container_name: airflow-flower
        restart: always
        depends_on:
            - redis
            - statsd-exporter
        # ports:
        #     - "5555:5555"
        command: airflow celery flower
        labels:
            # Enable Traefik for this specific "backend" service
            - traefik.enable=true
            # Define the port inside of the Docker service to use
            - traefik.http.services.flower.loadbalancer.server.port=5555
            # Make Traefik use this domain in HTTP
            - traefik.http.routers.flower-http.entrypoints=http
            - traefik.http.routers.flower-http.rule=Host(`flower.mon.${DOMAIN?Variable not set}`)
            # Use the traefik-public network (declared below)
            - traefik.docker.network=traefik-public

            # Make Traefik use this domain in HTTPS
            - traefik.http.routers.flower-https.entrypoints=https
            - traefik.http.routers.flower-https.rule=Host(`flower.mon.${DOMAIN?Variable not set}`)
            - traefik.http.routers.flower-https.tls=true
            # Use the "le" (Let's Encrypt) resolver
            - traefik.http.routers.flower-https.tls.certresolver=le
            # Middleware to redirect HTTP to HTTPS
            - traefik.http.routers.flower-http.middlewares=https-redirect
            - traefik.http.routers.flower-https.middlewares=admin-auth
        networks:
        # Use the public network created to be shared between Traefik and
        # any other service that needs to be publicly available with HTTPS
        - traefik-public
        - default

    scheduler:
        << : *airflow-common
        container_name: airflow-scheduler
        restart: always
        depends_on:
            - postgres
            - webserver
        command: airflow scheduler

    worker:
        << : *airflow-common
        container_name: airflow-worker
        restart: always
        sysctls:
            - net.ipv4.tcp_keepalive_time=200
            - net.ipv4.tcp_keepalive_intvl=200
            - net.ipv4.tcp_keepalive_probes=5
        depends_on:
            - redis
            - scheduler
        ports:
            - "8793"
        command: airflow celery worker

    statsd-exporter:
        image: prom/statsd-exporter
        container_name: airflow-statsd-exporter
        command: "--statsd.listen-udp=:8125 --web.listen-address=:9102 --statsd.mapping-config=/tmp/statsd_mapping.conf"
        ports:
            - "9102"
            - "8125/udp"
        volumes:
            - ./statsd/statsd_mapping.conf:/tmp/statsd_mapping.conf
    
    prometheus:
        image: prom/prometheus
        container_name: airflow-prometheus
        user: "0"
        # ports:
        #     - 9090:9090
        volumes:
            - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml
            - ./prometheus/volume:/prometheus
        labels:
            # Enable Traefik for this specific "backend" service
            - traefik.enable=true
            # Define the port inside of the Docker service to use
            - traefik.http.services.prometheus.loadbalancer.server.port=9090
            # Make Traefik use this domain in HTTP
            - traefik.http.routers.prom-http.entrypoints=http
            - traefik.http.routers.prom-http.rule=Host(`prom.mon.${DOMAIN?Variable not set}`)
            # Use the traefik-public network (declared below)
            - traefik.docker.network=traefik-public

            # Make Traefik use this domain in HTTPS
            - traefik.http.routers.prom-https.entrypoints=https
            - traefik.http.routers.prom-https.rule=Host(`prom.mon.${DOMAIN?Variable not set}`)
            - traefik.http.routers.prom-https.tls=true
            # Use the "le" (Let's Encrypt) resolver
            - traefik.http.routers.prom-https.tls.certresolver=le
            # Middleware to redirect HTTP to HTTPS
            - traefik.http.routers.prom-http.middlewares=https-redirect
            - traefik.http.routers.prom-https.middlewares=admin-auth
        networks:
        # Use the public network created to be shared between Traefik and
        # any other service that needs to be publicly available with HTTPS
        - traefik-public
        - default
        
    grafana:
        image: grafana/grafana:7.1.5
        container_name: airflow-grafana
        environment:
            GF_SECURITY_ADMIN_USER: ${MON_USERNAME?Variable not set}
            GF_SECURITY_ADMIN_PASSWORD: ${MON_PASSWORD?Variable not set}
            GF_PATHS_PROVISIONING: /grafana/provisioning
        # ports:
        #     - 3000:3000
        volumes:
            - ./grafana/volume/data:/grafana
            - ./grafana/volume/datasources:/grafana/datasources
            - ./grafana/volume/dashboards:/grafana/dashboards
            - ./grafana/volume/provisioning:/grafana/provisioning
        labels:
            # Enable Traefik for this specific "backend" service
            - traefik.enable=true
            # Define the port inside of the Docker service to use
            - traefik.http.services.grafana.loadbalancer.server.port=3000
            # Make Traefik use this domain in HTTP
            - traefik.http.routers.grafana-http.entrypoints=http
            - traefik.http.routers.grafana-http.rule=Host(`grafana.mon.${DOMAIN?Variable not set}`)
            # Use the traefik-public network (declared below)
            - traefik.docker.network=traefik-public

            # Make Traefik use this domain in HTTPS
            - traefik.http.routers.grafana-https.entrypoints=https
            - traefik.http.routers.grafana-https.rule=Host(`grafana.mon.${DOMAIN?Variable not set}`)
            - traefik.http.routers.grafana-https.tls=true
            # Use the "le" (Let's Encrypt) resolver
            - traefik.http.routers.grafana-https.tls.certresolver=le
            # Middleware to redirect HTTP to HTTPS
            - traefik.http.routers.grafana-http.middlewares=https-redirect
        networks:
        # Use the public network created to be shared between Traefik and
        # any other service that needs to be publicly available with HTTPS
        - traefik-public
        - default

    airflow-init:
        << : *airflow-common
        container_name: airflow-init
        depends_on:
            - postgres
            - redis
            - statsd-exporter
        entrypoint: /bin/bash
        command:
        - -c
        - airflow users list || ( airflow db init )
        restart: on-failure

volumes:
  postgres-db-volume:

networks:
  traefik-public:
    external: true